<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p>To get the password or a shared link, contribute something of value (hi-res/vector map, large batch of caves, or many edits/improvements to stubbed caves</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4aea04ded65040c821b0466b358b417794d03b9f077d03ed3de029df3c25acb515f07403a3b840579f7bbb7e0aac0dbe1822489a314c4606d5c6867d7c354782a28e86e96edb00cad32f2e9653ffaabe2c19c73ab56644f49d88154462dc24c1f38090b5826478b52cca3a82eefd8cd73753c14455ad65722a2d5c1d6186fe251ed97a07db139a51abd59245427dd78ffe5c19965e80eaeab50092b56b9b3b77bc14446d1df092b45c1021df567df3ad0973fd7f614bab37423936d47b9f5743dc170cecb9bcb2ecc8ee1ba3443e13cb7ddb5121a7c63f1830d2d0a8fe26fedc394dd94c3cf2938b7014e0e6d45e512e7e5a1786a6a150a08dc756bddb9103364bf4a1b1cb99ba779cd1405186e75778e79ede219904b51583fd9371ab3cd671b488c6dfda50a6b55f5261e9825806415c4eabec29d0eb47f013466e435b61585add5e913650216721116ef21ac7b6068170f7f431a0c4877de953ab1cd40e57feeefa63b7c5772a4c2b2a140b866601c1b27efb0288803e8780fef618e067d901cffda43f1abc98d239312143b72797d42e2e2a06944c9c99b604ba4d4468cf9c9aedb2047a2cdda829bd1408189711bf614e3968c7acd3768c8ca22cd77e7eef0c5cc622c82b24cefdab5251c454e62b79ab4d107f03607d18f0768b2a9b9b90ed856accd216537a8082f84364def7c13eb98c52a84acdc64d34a57c6941b352dce9f457aacecc2d8e21c3968beab0352ed77a3e26ca6b60bdb245468ee16a9db586ff408a42413379b624e5006287d63436aee8903726eff5784fcbf51c87cbaa7e830f13f90e46ab88f6d2024adeb734ac5eca08b61eebb6f386f6e50d10b0bc8079a1e59713c5ec8b1937fec6e3f9fd2cff13750bb515954f25be00a586ae25e4e62bc97f52c8fad9c13033bc96e79fcb0e708a180dc7fcc372b0b4ee66a9dc8c9efbe279122413ce43a115e777c06515b727fd6d509e302c1f6a61c5a7343105397995c756727a95e82e42e2bd7759c9d409945dab101557cb4baacd90f080f83a51d876eb4b655784ed1c37d36f54f20e2f781d74395b8cb135938737dc3833b1a9a31a207a055aa38aec86b45124128e15ea50d55e70959b6b6db741b1b6cb4115eae9439fedce7e64dc0d4f1646a7e65842b80abf6a8a037659c8e31f88faea54fb40ddab471bb1e2065e0cf229b54cff01745fd6af350898cc024a4802bbd296cb4b61591e03b447ede939bfb7d194a8785400843613ee4426f10fa6c535b19991efcbc4a0e494504238d3aac71394609a9b6cad62570908d427b3b48793ccc9ac8cc20cb69bd688e5e0da2a42eb4d0a71e0d8a797e31684ecb0243c29030a4c6c03b0786d57daa5ab6fbf9adbbf58412ff97a76db9682701ca8417c89a026ff0285a696a3f1eb188d3088c5711d8c2ae8002dffb6718a9e0c9ca059301262356e67b88bcb961df9703c7f9b1965f5d8fa91a7e9482e70c326f5e479e1dbae8d882868e829fda962d6474f67e5a42abb6549fbcfa699ba9616b903502a19a86f55bd4b426c540694e35626dfae6496f7c4e9ac029e62f595838b2126434bb593fa9661d688515b27cf4f173bbbc7c6efc04b09abce201db92eff7bdefba1cbf10aa241489593f9ff53d990fb36fd232087cda0be039baec161bde4d5b7d80830003d1007290c578eb9b9a9b168f2812ada33c127b1d24475f5ee4dd83c0e35c7e65ef61ba7c03ca77eff427bb17bf1f5ad13bacc7a6d0749d0011c0c791124b6abe9b40521569844c5bbf5adbcc29037634c6aba289a95a614628b3afc2e0c2f8d63157e4d15c4181cd5da30af494031e381c73b4f8d8bce2eeec4b127afff635f27aae28aadd2227d663a989ca6c2a91c743d29cb008ef921893c11eeccf6c59c2387db93b66516e70fd372369cc25d717de1781bfc3e5195c908c123015c79763a1bcd14e47003259aa81e89f8304b3855cb0d5db8a7ae6154e9668fcd0200680f70234f96f93a5737ef6d6b5dca611a0ea92ccbfb1499333ca2b46ed2eb56891f0fea8d160a7ac2c4effa9eb8cd65020f44d58bd80ddcbadaf01bc61cb6a25628c1767b65835918c3eec6453ae1b35ed3c5818d56197a0eb80c884db7234b80763893ec799fbfdc6b6fe523beb24b8539fc7f86be71484cca47acb27ee0cb2902fcc64faca569a2344aa3aa84d11328cfa642fd2c8a1b5a560c368df3a0f9f9f12f6121f79fb7a5ec3fef90ebd242f889bff4a8a2222c03f449842defda1bbba2a1303b567eb89b3df8ae703dd27940b0de891afc4018a1c542387043d2d2b4207b352b6c4dad0825825b37cb437fa36f67204c820d9020b1ecdaf8bf29c5f22d72eb6502123c5aea15b5a3acd0fb50dbffc0c7c8665d04424bb8797b7ede2d89230579453b14bdd8fae3e51eb7c2bda59c7b8d549afdc49aec6d0cd2ca1a0335d941889f6d4429f0df0d19834946d0c05800fd6c95deadc89d189f824c48ed23f794c633b71ff57778024968e4ba0f87b42d7f77e1fc1a667f23232f12ee64c1377338d5e9f1fd25399fa39688741988fb24cce8c8bada2c29be8cd75ef0ac2681ad1be411ec2c9d065181907517583e83b17a50b350c9402ae540da8d28d97689c3f68618dde6b0a19c0411738685b4207c3acaa4389251a98e43caabea005957540c20812d704aa395d942e6b28d9355a17ada3837b0ec94ea8df726cf8e012ee07b9ecc51ca5640e3d7ec788395a81510c75c45d5275f43ac9b4999f5472033f79b40d6a3fc350a079eaf9441de859e944379491bc1bbd251d2ae4e883a236c14b6a65f5ecba86b85f2ad72261fd7b2c91f385baf2b8c3e90b6a62d5e384e65ca93653bac3e39b849993290dadf51fa233a9e20bde66709da518550ab1b759f773cf22c66603fe8976d606630e253be8e0f318909a32519e7bbd7d561ef31f002380492023efd2c5a9fa4c5b3c1afd442b88e2700be9f343686a7dcdc266f073eaa4a382f9fa3aea867e4fb56d0efa1cf6e5b0f22a426e8e2097def3e1b1635e43f7ce230d992e6912b80be3927a51904023848083f45b0fdbf6d1dace9c6b4ec77034a92505e845aca95b53ab3e59c2ed35287d4eefb8b51768bbfb7f0f1b86c7283e688f8fc220f4c7394414dac8ee04a24d6ef041a675419e0d493e583ebd9da4094f12201bcfe70e4e1f06994bb9be86f8a45a5e7263115a4a2e5cb12566e0d641821aaea23224d0188c7b84b76a43acc428ce81c804182fdd9abc1188b61d54eed3058f993ccf720371fd4acc3ecdfe58085b1faca28fc9d7e4378e36a1a4b4a20af753001c7ddf98dfbfcf5d8742000f2ece92a09c647f1399c2afb0a817460cbd0ec074f8e2421a4f6f443f51b30955ed890a3abdf106b4f601356e49a9dd460f239b30169e03a71ebcc8f6700bace5cb4172c86dd68098c3fe44487572cf2706106f50d6cbc87f4b77ec2ae0ebae8e46d8e92c100b41e9369643b071c403349a8893760822428842a42c9e4d47f86dbd23df5877c3dc61e38997dd48050e59376c5f30697eb302dcee01d1321e0bbe24605af91d4ad7bb3af9278b1327b0196d128bef1486b128c16eb680fc0f938a92ad3c6d91a0dc59e2fbd944144fe7280509ef4229db56c164fabf4eb860340d28279af769c0e0c8f747d2e58f17f0dfb18287dba34aac6281a1535c9a665ab3efb05f7ddb7dffc8e0ff6864861477b50de14682e40d20b5a0cd98f609cf427b503f131b776a6515d2919c2c44add97edd85246dcc9c02cda7ffc1b7b4e0a74ce7c2f69f68ab2721ee19e851309db1350dae2c219078cc4cc70b72989d6e8f5ed61a272eebc128e2d584c686a789ed38726c4e246fc9ee3149713ba8802cf81783cc880363a36e07b7ce6e20df4160a36ddc656388df6c26e3cc6cafc741ebe4178be76b68ab9175bdd7fbbdde190672db682457e72646af2ac9e8c1b3a129ef202dffc7bfa06a6f60eb817bb13ed3454c64dd7f8c2aa06d739a75ce09834704f89829b6f7d9bfd989501783be92117f95d16ddff595f605ef78a88adeea6279eb5dd868844de79983c6acb0a541c771363de7d0cfe88f5a411f86327ce7ca67e3435a2274bf2659107215583762b6b192f1a5c3a0eb855d13bcd5113cfa01f2e8b2a419eaf87b5ec355f476f4b4736b1eb34106f535d5a910651bc7c34c54fc6bad4c218706d15b0ec7730ca84b0cdabe4a9a51857fcfd94cf2dc9ecdda6c1010c4132d068abf6705a9fcd03aaae0e5e9dac0f794a064ad9f9104b45fff2d508adfa55551eb78436b64afabe82c829ee0bc62454b53559d099acfb336fdfb7c91e7bded3d4820460df5d694e4275bea2caa067e98a2780769878bd2628f0125887b25c42cca5ac9734227debae4808a74be2be957f94506addcc46fdb63dd70d870a779a10cf37504d20d8b565fe3df68742019f61ea2f7a31ededd9fe8b6cf987309720874602b3ba19efa3781e4975a2af46ac3037e8123c2e86c12c7351b8727b84ed263c432b40a3e08ac3ca340cb5ed9d51e752e684aafba680ba8265208b70d5d265948b5ce860555590dfc183fca36da882ad91dc32786b6852f1961496393a96939345e3bbd8f8b7552d5f61a9219279ba3f0e0012d68d0c263a89046ae8c2e97bcb7ece006cce2e14d196bc09870795ef8ed9d1b74ece594ba62b8ae8e4724a17c42da40df04cc5e108e9440e34f5119221304614c76743fdec26acff7d2359dec627a5f405416625b54d855a282b71703f6b3847cde6257cae69515b73d0966bd0d10b02b08d3f8bfa1788debed286d3a722f92c9493ceb77bffd94d9dc0c841dfb6a27ac9a15d7f18663620bacf085bd53fafc01620d96a0690ab890f11c35883be7625b9b6b6ba8b6b569b2f4adbb281f03864c20c3a2b17d780129b5a0fb39bdf30efcd248ed1615f02fdf5c9f6472df716d1ea4b715719a45066d7e5bd6407e93ca9e689b8d79f32d7ddb6cf7d16dd35b9deaa7940696d291320468cb169fd5a111e0580e0b6bf11cebdfd79ec68d7d75eeea2229403d23a9fbd8c30726bb1bdbfee9016a92d7360cac4daf751556ffb6f47698ab4e506852cb0d0032f4a3796eec9fe32549d102130f92a91d5925218a36252021a31bc96915796367bcf0f470878ae25c5b7c23529565deb19ae39002a51e73fd91e230d030a36d3dbbaf1aa800bbf89b43f39ebfb7d87fe93f9fd17ad0335760337fd7c6aad78b4159bcc104d15d7bf502ecf297c6c376d1c6cf18438a83d8572aef8897d58eedf8d0da22536c0a543b09faccd46b2b9f37c57ae5290be66e45fbe3dd014df7d22538a67954a098d97bcff35764ff8a83beee5a779e13dbb0bd723b5c3434bca8ce946ce85ff9539f7e93c3c005e753672ec9e4a76504949bbb4c1ad85047e215171f5f399cae6ebc154c0512928c95a5dd8662029478f6a843b1eff51ec9e7ae4cecca302cd3a2ee90c3d864dd0d41211821f92251765ef6c3537db2ab491e8cfb0fddbb66881003d8490d06d65bd0d6900f520bf4f2113b12aae4801e5e80ead4f40e7201ebe04bf1b16efd3345c4cbc0c349324470db47c3c7afb660059e4177ff0353dd613a26d4a045ba098e75f21c7724030f1b5e95bc1e8ab361af78eac14daad1393d7ba09be1cb43f769166fdefe29b507f8a2493adf277f4109656659dcd768313ec78676023798ca2557cc0965e8a0674361634f1c47632d279a232775093509744d52467d13980fa9819690ae6959d113f16a8a4aed36e56a7d9851d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b924fb5956b33478e6915983c7f05959"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
